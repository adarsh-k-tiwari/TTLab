[2:03 PM] Singh, Shagun
use egui::{Align, CentralPanel, CtxRef, Label, SidePanel, TextBox, TopPanel, Ui, Window};  

use egui_glium::Painter;  

use glium::glutin;  

use glium::Surface;  

use serde::{Deserialize, Serialize};  

use std::fs::{File, OpenOptions};  

use std::io::{Read, Write};  

use std::path::Path;  

#[derive(Clone, Debug, Default, Serialize, Deserialize)]  

struct Task {  

    title: String,  

    completed: bool,  

}  

impl Task {  

    fn new(title: String) -> Self {  

        Self {  

            title,  

            completed: false,  

        }  

    }  

    fn load_tasks_from_file(file_path: &str) -> Result<Vec<Task>, Box<dyn std::error::Error>> {  

        let mut file = File::open(file_path)?;  

        let mut contents = String::new();  

        file.read_to_string(&mut contents)?;  

        let tasks: Vec<Task> = serde_json::from_str(&contents)?;  

        Ok(tasks)  

    }  

    fn save_tasks_to_file(tasks: &[Task], file_path: &str) -> Result<(), Box<dyn std::error::Error>> {  

        let contents = serde_json::to_string_pretty(tasks)?;  

        let mut file = OpenOptions::new()  

            .write(true)  

            .create(true)  

            .truncate(true)  

            .open(file_path)?;  

        file.write_all(contents.as_bytes())?;  

        Ok(())  

    }  

}  

fn main() {  

    let event_loop = glutin::event_loop::EventLoop::new();  

    let window = glutin::window::WindowBuilder::new()  

        .with_decorations(true)  

        .with_resizable(true)  

        .with_title("To-Do App");  

    let context = glutin::ContextBuilder::new().with_vsync(true);  

    let display = glium::Display::new(window, context, &event_loop).unwrap();  

    let mut tasks = match Task::load_tasks_from_file("tasks.json") {  

        Ok(tasks) => tasks,  

        Err(err) => {  

            println!("Error loading tasks: {}", err);  

            Vec::new()  

        }  

    };  

    let mut new_task_title = String::new();  

    event_loop.run(move |event, _, control_flow| {  

        *control_flow = glium::glutin::event_loop::ControlFlow::Poll;  

        match event {  

            glutin::event::Event::WindowEvent { event, .. } => match event {  

                glutin::event::WindowEvent::CloseRequested => {  

                    if let Err(err) = Task::save_tasks_to_file(&tasks, "tasks.json") {  

                        println!("Error saving tasks: {}", err);  

                    }  

                    *control_flow = glium::glutin::event_loop::ControlFlow::Exit;  

                }  

                _ => (),  

            },  

            glutin::event::Event::MainEventsCleared => {  

                display.gl_window().window().request_redraw();  

            }  

            glutin::event::Event::RedrawRequested(_) => {  

                let frame = display.draw();  

                let mut egui_ctx = CtxRef::default();  

                egui_ctx.begin_frame();  

                TopPanel::top("top_panel").show(&egui_ctx, |ui| {  

                    ui.heading("To-Do App");  

                });  

                SidePanel::left("side_panel").show(&egui_ctx, |ui| {  

                    ui.heading("Add Task");  

                    TextBox::multiline(&mut new_task_title).ui(ui);  

                    if ui.button("Add").clicked() {  

                        if !new_task_title.is_empty() {
                        let task = Task::new(new_task_title.clone());  

                        tasks.push(task);  

                        new_task_title.clear();  

                    }  

                }  

            });  

            CentralPanel::default().show(&egui_ctx, |ui| {  

                ui.heading("Tasks");  

                for task in &mut tasks {  

                    ui.horizontal(|ui| {  

                        let completed = &mut task.completed;  

                        ui.checkbox(completed, &task.title);  

                    });  

                }  

            });  

            let (_output, paint_commands) = egui_ctx.end_frame();  
            let paint_jobs = egui_ctx.tessellate(paint_commands);  
            frame.clear_color(0.5, 0.5, 0.5, 1.0);  
            let painter = Painter::new(&display);  
            painter.paint(&frame, paint_jobs);  
            frame.finish().unwrap();
        }
        _ => (),
    });
}
